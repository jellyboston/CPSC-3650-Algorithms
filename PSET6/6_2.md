### Part 2
#### Prove `update` function for bidirectional edges

##### Definitions: 
"capacity constraint":
For every directed edge $(u,v)$ in $G$,
$$
0\leq f(u,v)\leq c(u,v)
$$
where $f(u,v)$ and $c(u,v)$ represent the flow and capacity across two arbitrary vertices $u$ and $v$

"new single-direction flow constraint":
$$
\text{Flow only goes one way:}\\\\
\text{if}f(u,v)>0 \text{ then }f(v,u)=0 
$$

##### WTS:
* New `update` function for bidirectional edges satisfies these two

##### Precondition:
* Before `update()` is called, assume the flow satisfies both constraints

##### Step 1: Positive flow in the opposite direction
* Capacity constraint: We take the minimum between $b$ (the amount of flow) and `reverse.flow()` (which represents the amount of flow that can be subtracted). This prevents a large flow from being chosen and subtracted from the reverse that breaks the capacity the reverse flow has when we call `reverse.add_flow(-c)`. THus, capacity constraint is conserved. 
* Single-direction is maintained because we haven't increased $e.flow$ yet (only acting on the reverse direction). 

##### Step 2: Update flow in the forward direction
* If the invariant initially holds (no positive flow in both directions), then after applying update(e, e.opposite(), b) the same remains true because one of the flows increases while the other decreases by the same amount (never making both positive).
* WTS: Capacity preserved by $b \leq \text{residual}(e)$
* After cancelling, the remainder is $r=b-c$. By computing `safe_add`, we implement a cap by utilizing the residual of the edge, which by definition tracks how much flow is left to push. This prevents overflowing the edge's capacity, thus the invariant is preserved:
```python
safe_add = min(r, e.residual())
```
* Step A ensured ??? (how do we show single-direction constraint here?)